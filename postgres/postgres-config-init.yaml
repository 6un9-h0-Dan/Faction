apiVersion: v1
kind: ConfigMap
metadata:
    name: postgres-config-init
    labels:
        app: postgres
data:
    faction.sql: |+
        SET statement_timeout = 0;
        SET lock_timeout = 0;
        SET idle_in_transaction_session_timeout = 0;
        SET client_encoding = 'UTF8';
        SET standard_conforming_strings = on;
        SET check_function_bodies = false;
        SET xmloption = content;
        SET client_min_messages = warning;
        SET row_security = off;
        SET default_tablespace = '';
        SET default_table_access_method = heap;
        CREATE EXTENSION IF NOT EXISTS pgcrypto WITH SCHEMA public;
        COMMENT ON EXTENSION pgcrypto IS 'cryptographic functions';

        /*
            Functions
        */
        CREATE OR REPLACE FUNCTION random_range(INTEGER, INTEGER)
            RETURNS INTEGER
            LANGUAGE SQL
        AS
        $$
        SELECT ($1 + FLOOR(($2 - $1 + 1) * random()))::INTEGER;
        $$;

        CREATE OR REPLACE FUNCTION random_text(length INTEGER)
            RETURNS TEXT
            LANGUAGE PLPGSQL
        AS
        $$
        DECLARE
            possible_chars TEXT := '0123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghjkmnpqrstuvwxyz';
            output         TEXT := '';
            i              INT4;
            pos            INT4;
        BEGIN
            FOR i IN 1..length
                LOOP
                    pos := random_range(1, length(possible_chars));
                    output := output || substr(possible_chars, pos, 1);
                END LOOP;
            RETURN output;
        END;
        $$;

        ALTER FUNCTION random_text(length integer) OWNER TO postgres;

        --------------------------------------------------------------------------
        /*
            Agents are the result of running a payload on an endpoint. They have connected, staged
            and we can interact with them.
        */
        CREATE TABLE agents
        (
            id                  uuid DEFAULT public.gen_random_uuid() PRIMARY KEY,
            agent_type_id       uuid,
            staging_id          uuid,
            name                text DEFAULT random_text(8) NOT NULL,
            secret_key          text,
            username            text,
            hostname            text,
            pid                 integer,
            operating_system    text,
            admin               boolean,
            payload_id          uuid NOT NULL,
            staging_response_id uuid NOT NULL,
            internal_ip         text,
            external_ip         text,
            initial_checkin     timestamp without time zone default (now() at time zone 'utc'),
            last_checkin        timestamp without time zone,
            transport_id        uuid NOT NULL,
            beacon_interval     integer,
            jitter              double precision,
            visible             boolean DEFAULT true NOT NULL,
            metadata            jsonb
        );

        /*
            This xref provides a mapping between an agent and what modules it has loaded
        */
        CREATE TABLE agent_modules_xref
        (
            agent_id  uuid NOT NULL,
            module_id uuid NOT NULL,
            PRIMARY KEY (agent_id, module_id)
        );


        /*
            Agent Checkins are messages from an agent to Faction. These checkins may contain
            the results of tasks (agent_task_update) that have been issued, or it they may be empty. 
        */
        CREATE TABLE agent_checkins
        (
            id           uuid DEFAULT public.gen_random_uuid() PRIMARY KEY,
            agent_id     uuid,
            transport_id uuid NOT NULL,
            source_ip    text,
            iv           text,
            hmac         text,
            message      text,
            received     timestamp without time zone default (now() at time zone 'utc'),
            metadata     jsonb
        );

        /*
            Agent Tasks are commands issues to the agent. These are encrypted as agent task messages
            and sent to the agent.
        */
        CREATE TABLE agent_tasks
        (
            id                 uuid DEFAULT public.gen_random_uuid() PRIMARY KEY,
            agent_id           uuid NOT NULL,
            console_message_id uuid,
            command            text,
            created            timestamp without time zone default (now() at time zone 'utc') NOT NULL,
            metadata           jsonb
        );

        /*
            Message queue is where the encrypted messages that are sent from Faction to an Agent are
            stored. They should always be associated with a task
        */
        CREATE TABLE message_queue
        (
            id            uuid DEFAULT public.gen_random_uuid() PRIMARY KEY,
            agent_id      uuid NOT NULL,
            agent_task_id uuid NOT NULL,
            route_info    text,
            iv            text,
            hmac          text,
            message       text,
            sent          boolean,
            created       timestamp without time zone default (now() at time zone 'utc') NOT NULL,
            metadata      jsonb
        );

        /*
            Agent Task Updates are are the results of a task (hopefully that's obvious). An agent task update
            does not necessarily mean that the task has completed. We need to account for long running tasks
            that result in multiple updates (Scan at 10%, Scan at 80%, Scan Complete.)
        */
        CREATE TABLE agent_task_updates
        (
            id         uuid DEFAULT public.gen_random_uuid() PRIMARY KEY,
            agent_id   uuid NOT NULL,
            task_id    uuid,
            message    text,
            type       text,
            content    text,
            content_id text, /* This is here so we can group multiple updates for a task.. I think. */
            complete   boolean,
            success    boolean,
            received   timestamp without time zone default (now() at time zone 'utc'),
            metadata   jsonb
        );


        /*
            Agent Types are the types of agents available in Faction. When an agent type is added it needs
            to tell us:

            - Its Name
            - What module types it supports
            - Whether its in developement (this affects some staging settings)
        */
        CREATE TABLE agent_types
        (
            id           uuid DEFAULT public.gen_random_uuid() PRIMARY KEY,
            name         text UNIQUE,
            authors      text[],
            development  boolean NOT NULL,
            module_types text[],
            metadata     jsonb
        );

        /*
            API Keys are the primary way of authenticating to Faction. A user sends their user/pass to the Auth service,
            the Auth service issues an API key for them to use. API keys, like passwords are stored with encrypted with 
            bcrypt. There is no way to recover the plain text API key after its been created
        */
        CREATE TABLE api_keys
        (
            id          uuid DEFAULT public.gen_random_uuid() PRIMARY KEY,
            user_id     uuid  NOT NULL,
            role_id     uuid,
            name        text DEFAULT random_text(14) NOT NULL,
            description text  NOT NULL,
            key         bytea NOT NULL,
            created     timestamp without time zone default (now() at time zone 'utc'),
            last_used   timestamp without time zone,
            enabled     boolean DEFAULT true,
            visible     boolean DEFAULT true,
            metadata    jsonb
        );

        /*
            Commands are associated with agent types (builtin) or modules. When an agent type or module is created
            it adds whatever commands it provides to the database. This is used for autocomplete info as well as preventing
            invalid commands from being sent down to agents.
        */
        CREATE TABLE commands
        (
            id              uuid DEFAULT public.gen_random_uuid() PRIMARY KEY,
            name            text,
            description     text,
            help            text,
            mitre_reference text,
            opsec_safe      boolean NOT NULL,
            artifacts       text[],
            module_id       uuid,
            agent_type_id   uuid,
            metadata        jsonb,
            UNIQUE (name, module_id)
        );

        CREATE TABLE command_parameters
        (
            id         uuid DEFAULT public.gen_random_uuid() PRIMARY KEY,
            name       text,
            help       text,
            required   boolean NOT NULL,
            position   integer,
            values     text,
            command_id uuid    NOT NULL,
            metadata   jsonb,
            UNIQUE (name, command_id)
        );

        /*
            Console Messages are what is displayed on the console for end users. This includes input from a user as well
            as system messages and messages from agents. Console message always need to be associated with an agent, as 
            thats what our console is "looking" at.
        */
        CREATE TABLE console_messages
        (
            id            uuid DEFAULT public.gen_random_uuid() PRIMARY KEY,
            agent_id      uuid NOT NULL,
            user_id       uuid,
            agent_task_id uuid,
            type          text,
            content       text,
            received      timestamp without time zone default (now() at time zone 'utc'),
            metadata      jsonb
        );

        /*
            Error Messages
        */
        CREATE TABLE error_messages
        (
            id        uuid DEFAULT public.gen_random_uuid() PRIMARY KEY,
            source    text,
            message   text,
            details   text,
            timestamp timestamp without time zone default (now() at time zone 'utc'),
            metadata  jsonb
        );

        /*
            Files are associated with several events in faction: payload creation, user uploads, files
            pulled from endpoints, modules. Some notes about the fields here:

            - Description: This is a free form field that so users can name their files whatever they want
            - Type: This should be whats details above (Module, Payload, User, Agent, etc)
            - File Path: This is the location on disk for the file
            - Source File Path: This is used for files recieved from agents to keep record of where they were found
            - Public Key: If a file is made publically available (as in, you don't need to log in to Faction to download it)
            this field is used to store a key used to retrieve the file. If it is null, then you must auth to Faction to download it
            - URL: Where to download the file from. 
        */
        CREATE TABLE files
        (
            id               uuid DEFAULT public.gen_random_uuid() PRIMARY KEY,
            description      text,
            type             text,
            hash             text,
            file_path        text,
            agent_id         uuid,
            source_file_path text,
            user_id          uuid NOT NULL,
            created          timestamp without time zone default (now() at time zone 'utc'),
            last_downloaded  timestamp without time zone,
            enabled          boolean DEFAULT true NOT NULL,
            public_key       text,
            url              text,
            metadata         jsonb
        );

        /*
            IOCs
        */
        CREATE TABLE iocs
        (
            id                   uuid DEFAULT public.gen_random_uuid() PRIMARY KEY,
            description          text,
            type                 text,
            identifier           text,
            hash                 text,
            action               text,
            agent_task_update_id uuid NOT NULL,
            user_id              uuid NOT NULL,
            timestamp            timestamp without time zone NOT NULL,
            metadata             jsonb
        );


        /*
            Modules are binaries that provide commands and functionality to an agent.
        */
        CREATE TABLE modules
        (
            id          uuid DEFAULT public.gen_random_uuid() PRIMARY KEY,
            name        text,
            description text,
            authors     text,
            module_type text NOT NULL,
            metadata    jsonb,
            UNIQUE (name, module_type)
        );

        /*
            Payload Types are created by Agent Types. They dictate what payloads can be created. Of note is the
            configuration_schema field which stores a json blob that defines what configuration options are available
            for this payload type. This can include things like OS, Architecture, etc. The Faction UI will render this
            schema as a form when the user goes to create their payload. 

            Each payload type is associated with a type of transport through the transport_guid field
        */
        CREATE TABLE payload_type
        (
            id                   uuid DEFAULT public.gen_random_uuid() PRIMARY KEY,
            name                 text,
            description          text,
            agent_type_id        uuid NOT NULL,
            transport_guid       uuid NOT NULL,
            metadata             jsonb,
            configuration_schema json
        );

        /*
            Payloads are files that spawn an agent. When a payload is executed, it reaches out to Faction,
            goes through a staging process, and then registers as an agent.

            Of note here is the configuration field which stores the values rendered from the configuration_schema
            on the payload_type object. When a new payload entry is created, the payload configuration as well as
            the configuration for its associated transport are sent to a build service. The build service parses this 
            information, builds the payload, uploads it to the file service, then updates the payload entry with 
            the file id.
        */
        CREATE TABLE payloads
        (
            id              uuid DEFAULT public.gen_random_uuid() PRIMARY KEY,
            payload_type_id uuid NOT NULL,
            transport_id    uuid NOT NULL,
            file_id         uuid NOT NULL,
            name            text DEFAULT random_text(12),
            description     text,
            staging_key     text,
            last_downloaded timestamp without time zone,
            expiration_date timestamp without time zone,
            configuration   jsonb,
            created         timestamp without time zone default (now() at time zone 'utc'),
            visible         boolean DEFAULT TRUE NOT NULL,
            enabled         boolean DEFAULT TRUE NOT NULL,
            created_by      uuid NOT NULL,
            metadata        jsonb
        );

        /*
            Staging Messages are the initial message a payload sends when it reaches out to Faction. Faction responds to
            this message with the information required to establish an agent (a new encryption key, etc)
        */
        CREATE TABLE staging_messages
        (
            id                  uuid DEFAULT public.gen_random_uuid() PRIMARY KEY,
            payload_id          uuid NOT NULL,
            source_ip           text,
            transport_id        uuid NOT NULL,
            staging_id          text,
            staging_response_id uuid,
            iv                  text,
            hmac                text,
            message             text,
            received            timestamp without time zone,
            metadata            jsonb
        );

        CREATE TABLE staging_responses
        (
            id                 uuid DEFAULT public.gen_random_uuid() PRIMARY KEY,
            agent_id           uuid,
            staging_message_id uuid    NOT NULL,
            iv                 text,
            hmac               text,
            message            text,
            created            timestamp without time zone default (now() at time zone 'utc'),
            sent               boolean NOT NULL DEFAULT FALSE,
            metadata           jsonb
        );

        /*
            Transports serve as the point of contact for an agent. They sit between Faction and the agent and handle
            transposing messages as appropriate. Each transport has a unique guid to identify it by, this way when a
            payload type is created, it can list what transport type it supports

            Transports have their own configuration that is sent along when a payload build is request. This is expected
            to be configuration that shapes how its traffic is handled (for example, what HTTP headers the client 
            should add, where to put messages and stuff)
        */
        CREATE TABLE transports
        (
            id             uuid DEFAULT public.gen_random_uuid() PRIMARY KEY,
            transport_guid uuid NOT NULL,
            name           text,
            protocol       text,
            configuration  jsonb,
            created        timestamp without time zone default (now() at time zone 'utc'),
            enabled        boolean DEFAULT true NOT NULL,
            visible        boolean DEFAULT true NOT NULL,
            metadata       jsonb
        );


        /*
            Users
        */
        CREATE TABLE user_roles
        (
            id       uuid DEFAULT public.gen_random_uuid() PRIMARY KEY,
            name     text NOT NULL,
            metadata jsonb
        );

        CREATE TABLE users
        (
            id         uuid DEFAULT public.gen_random_uuid() PRIMARY KEY,
            username   text UNIQUE,
            password   bytea,
            role_id    uuid,
            created    timestamp without time zone default (now() at time zone 'utc'),
            last_login timestamp without time zone,
            enabled    boolean DEFAULT true NOT NULL,
            visible    boolean DEFAULT true NOT NULL,
            metadata   jsonb
        );


        /*
            Foreign Keys
        */
        ALTER TABLE ONLY agents
            ADD CONSTRAINT agent_agent_type_id_fkey
                FOREIGN KEY (agent_type_id) REFERENCES agent_types (id) ON DELETE RESTRICT;

        ALTER TABLE ONLY agents
            ADD CONSTRAINT agent_payload_id_fkey
                FOREIGN KEY (payload_id) REFERENCES payloads (id) ON DELETE RESTRICT;

        ALTER TABLE ONLY agent_checkins
            ADD CONSTRAINT agent_checkin_agent_id_fkey
                FOREIGN KEY (agent_id) REFERENCES agents (id) ON DELETE RESTRICT;

        ALTER TABLE ONLY agent_checkins
            ADD CONSTRAINT agent_checkin_transport_id_fkey
                FOREIGN KEY (transport_id) REFERENCES transports (id) ON DELETE CASCADE;

        ALTER TABLE ONLY agent_modules_xref
            ADD CONSTRAINT agent_modules_xref_agent_id_fkey
                FOREIGN KEY (agent_id) REFERENCES agents (id) ON DELETE RESTRICT;

        ALTER TABLE ONLY agent_modules_xref
            ADD CONSTRAINT agent_modules_xref_module_id_fkey
                FOREIGN KEY (module_id) REFERENCES modules (id) ON DELETE RESTRICT;

        ALTER TABLE ONLY agent_tasks
            ADD CONSTRAINT agent_task_agent_id_fkey
                FOREIGN KEY (agent_id) REFERENCES agents (id) ON DELETE CASCADE;

        ALTER TABLE ONLY agent_tasks
            ADD CONSTRAINT agent_task_console_message_id_fkey
                FOREIGN KEY (console_message_id) REFERENCES console_messages (id) ON DELETE RESTRICT;

        ALTER TABLE ONLY agent_task_updates
            ADD CONSTRAINT agent_task_update_agent_id_fkey
                FOREIGN KEY (agent_id) REFERENCES agents (id) ON DELETE RESTRICT ;

        ALTER TABLE ONLY agent_task_updates
            ADD CONSTRAINT agent_task_update_task_id_fkey
                FOREIGN KEY (task_id) REFERENCES agent_tasks (id) ON DELETE RESTRICT;

        ALTER TABLE ONLY message_queue
            ADD CONSTRAINT message_queue_agent_task_id_fkey
                FOREIGN KEY (agent_id) REFERENCES agents (id) ON DELETE RESTRICT;

        ALTER TABLE ONLY api_keys
            ADD CONSTRAINT api_keys_users_fkey
                FOREIGN KEY (user_id) REFERENCES users (id);

        ALTER TABLE ONLY api_keys
            ADD CONSTRAINT api_keys_user_roles_id_fkey
                FOREIGN KEY (role_id) REFERENCES user_roles (id);

        ALTER TABLE ONLY commands
            ADD CONSTRAINT command_agent_type_id_fkey
                FOREIGN KEY (agent_type_id) REFERENCES agent_types (id) ON DELETE RESTRICT;

        ALTER TABLE ONLY commands
            ADD CONSTRAINT command_module_id_fkey
                FOREIGN KEY (module_id) REFERENCES modules (id) ON DELETE RESTRICT;

        ALTER TABLE ONLY command_parameters
            ADD CONSTRAINT command_parameter_command_id_fkey
                FOREIGN KEY (command_id) REFERENCES commands (id) ON DELETE RESTRICT;

        ALTER TABLE ONLY console_messages
            ADD CONSTRAINT console_message_agent_id_fkey
                FOREIGN KEY (agent_id) REFERENCES agents (id) ON DELETE RESTRICT;

        ALTER TABLE ONLY console_messages
            ADD CONSTRAINT console_message_user_id_fkey
                FOREIGN KEY (user_id) REFERENCES users (id) ON DELETE RESTRICT;

        ALTER TABLE ONLY files
            ADD CONSTRAINT file_agent_id_fkey
                FOREIGN KEY (agent_id) REFERENCES agents (id) ON DELETE RESTRICT;

        ALTER TABLE ONLY files
            ADD CONSTRAINT file_user_id_fkey
                FOREIGN KEY (user_id) REFERENCES users (id) ON DELETE RESTRICT;

        ALTER TABLE ONLY iocs
            ADD CONSTRAINT ioc_user_id_fkey
                FOREIGN KEY (user_id) REFERENCES users (id) ON DELETE CASCADE;

        ALTER TABLE ONLY iocs
            ADD CONSTRAINT ioc_agent_task_update_id_fkey
                FOREIGN KEY (agent_task_update_id) REFERENCES agent_task_updates (id) ON DELETE RESTRICT;

        ALTER TABLE ONLY payloads
            ADD CONSTRAINT payload_transport_id_fkey
                FOREIGN KEY (transport_id) REFERENCES transports (id) ON DELETE RESTRICT;

        ALTER TABLE ONLY payloads
            ADD CONSTRAINT payload_agent_type_id_fkey
                FOREIGN KEY (payload_type_id) REFERENCES payload_type (id) ON DELETE RESTRICT;

        ALTER TABLE ONLY payloads
            ADD CONSTRAINT payloads_created_by_fkey
                FOREIGN KEY (created_by) REFERENCES users (id) ON UPDATE RESTRICT ON DELETE RESTRICT;

        ALTER TABLE ONLY payloads
            ADD CONSTRAINT payloads_file_fkey
                FOREIGN KEY (file_id) REFERENCES files (id) ON UPDATE RESTRICT ON DELETE RESTRICT;

        ALTER TABLE ONLY staging_messages
            ADD CONSTRAINT staging_message_payload_id_fkey
                FOREIGN KEY (payload_id) REFERENCES payloads (id) ON DELETE CASCADE;

        ALTER TABLE ONLY staging_messages
            ADD CONSTRAINT staging_message_staging_response_id_fkey
                FOREIGN KEY (staging_response_id) REFERENCES staging_responses (id) ON DELETE RESTRICT;

        ALTER TABLE ONLY staging_responses
            ADD CONSTRAINT staging_response_agent_id_fkey
                FOREIGN KEY (agent_id) REFERENCES agents (id) ON DELETE RESTRICT;

        ALTER TABLE ONLY users
            ADD CONSTRAINT user_role_id_fkey
                FOREIGN KEY (role_id) REFERENCES user_roles (id) ON DELETE RESTRICT;
        /*
            Indexes
        */
        CREATE UNIQUE INDEX agent_name_uindex ON agents USING btree (name);
        CREATE UNIQUE INDEX agent_task_name_uindex ON agent_tasks USING btree (id);
        CREATE UNIQUE INDEX api_keys_id_uindex ON api_keys USING btree (id);
        CREATE UNIQUE INDEX api_keys_name_uindex ON api_keys USING btree (name);
        CREATE UNIQUE INDEX agent_task_console_message_id_uindex ON agent_tasks USING btree (console_message_id);
        CREATE UNIQUE INDEX message_queue_agent_task_id_uindex ON message_queue USING btree (agent_task_id);
        CREATE UNIQUE INDEX staging_message_staging_response_id_uindex ON staging_messages USING btree (staging_response_id);
        CREATE UNIQUE INDEX staging_response_agent_id_uindex ON staging_responses USING btree (agent_id);
        CREATE UNIQUE INDEX payload_filename_uindex ON payloads USING btree (file_id);
        CREATE UNIQUE INDEX payload_name_uindex ON payloads USING btree (name);
        CREATE INDEX agent_agent_type_id_index ON agents USING btree (agent_type_id);
        CREATE INDEX agent_checkin_agent_id_index ON agent_checkins USING btree (agent_id);
        CREATE INDEX agent_checkin_transport_id_index ON agent_checkins USING btree (transport_id);
        CREATE INDEX agent_payload_id_index ON agents USING btree (payload_id);
        CREATE INDEX agent_task_agent_id_index ON agent_tasks USING btree (agent_id);
        CREATE INDEX message_agent_task_id_index ON message_queue USING btree (agent_task_id);
        CREATE INDEX agent_task_update_agent_id_index ON agent_task_updates USING btree (agent_id);
        CREATE INDEX agent_task_update_task_id_index ON agent_task_updates USING btree (task_id);
        CREATE INDEX agent_modules_xref_module_id_index ON agent_modules_xref USING btree (module_id);
        CREATE INDEX command_agent_type_id_index ON commands USING btree (agent_type_id);
        CREATE INDEX command_module_id_index ON commands USING btree (module_id);
        CREATE INDEX command_parameter_command_id_index ON command_parameters USING btree (command_id);
        CREATE INDEX console_message_agent_id_index ON console_messages USING btree (agent_id);
        CREATE INDEX console_message_user_id_index ON console_messages USING btree (user_id);
        CREATE INDEX file_agent_id_index ON files USING btree (agent_id);
        CREATE INDEX file_user_id_index ON files USING btree (user_id);
        CREATE INDEX ioc_agent_task_update_id_index ON iocs USING btree (agent_task_update_id);
        CREATE INDEX ioc_user_id_index ON iocs USING btree (user_id);
        CREATE INDEX payload_transport_id_index ON payloads USING btree (transport_id);
        CREATE INDEX staging_message_payload_id_index ON staging_messages USING btree (payload_id);
        CREATE INDEX staging_message_transport_id_index ON staging_messages USING btree (transport_id);
        CREATE INDEX user_role_id_index ON users USING btree (role_id);
